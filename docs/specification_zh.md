# 语义 Python 语言规范

## 1. 概述

### 1.1 语义 Python 的定义

语义 Python 是 Python 语言的扩展，在保持完全语法兼容的前提下，引入了**语义调用**这一新的调用形式。语义调用与函数调用、方法调用处于同一抽象层级，构成了 Python 调用机制的第三种形态。

### 1.2 与标准 Python 的关系

在标准 Python 中，当解释器遇到无法解析的函数或方法调用时，会抛出 `NameError` 或 `AttributeError` 异常。语义 Python 改变了这一行为：

- **标准 Python**：无法解析的调用 → 运行时错误
- **语义 Python**：无法解析的调用 → 语义调用 → 语义执行流

这种改变使得程序员可以编写在语法上合法但在传统意义上"不完整"的代码，将部分计算的实现推迟到运行时通过语义推理完成。

## 2. 语义调用

### 2.1 语义调用的定义

**语义调用**是指在程序执行过程中，当遇到无法解析为可执行函数对象的调用表达式时，该调用被识别为语义调用，并转入语义执行流程。

形式上，以下情况构成语义调用：

1. **未定义的函数调用**：调用的函数名在当前作用域及所有外层作用域中都无法解析

   ```python
   result = analyze_sentiment(text)  # analyze_sentiment 未定义
   ```

2. **未定义的方法调用**：对象上调用的方法在该对象的类及其继承链中都不存在

   ```python
   customer.calculate_lifetime_value()  # Customer 类没有此方法
   ```

### 2.2 语义调用的识别时机

语义调用的识别发生在**运行时**而非编译时或解析时。这意味着：

- 代码在语法分析阶段是合法的 Python 代码
- 只有在实际执行到调用语句时，才会判定该调用是否为语义调用
- 这保持了 Python 的动态特性和语法兼容性

### 2.3 语义调用与传统调用的对比

| 特性 | 函数/方法调用 | 语义调用 |
|------|---------------|----------|
| 解析时机 | 运行时解析为函数对象 | 运行时无法解析 |
| 实现位置 | 代码中明确定义 | 运行时推理生成 |
| 行为确定性 | 完全确定 | 由意图和上下文决定 |
| 错误处理 | 未定义则抛出异常 | 未定义则进入语义流 |

## 3. 意图表达机制

### 3.1 调用上下文

当程序进入语义执行流时，语义执行引擎需要理解程序员的意图。意图信息蕴含在**调用上下文**中。

调用上下文包括：

1. **代码容器**（按优先级）：
   - 如果调用在类的内部：该类的完整定义
   - 否则，如果调用在函数的内部：该函数的完整定义
   - 否则：该模块的相关代码

2. **类型信息**：
   - 调用参数的类型（通过类型注解或推断）
   - 返回值的类型（通过类型注解或推断）
   - 相关类型的完整定义

3. **标识符**：
   - 调用的函数/方法名称
   - 参数名称
   - 相关变量名称

4. **文档和注释**：
   - 相关代码的文档字符串
   - 相关代码的注释

### 3.2 意图的编码

意图不是代码本身，而是程序员期望语义调用完成的任务。意图通过上述调用上下文中的多个维度协同编码：

- **类型签名**传达输入输出的数据结构
- **标识符**承载自然语言语义，暗示任务性质
- **代码逻辑**揭示业务场景和计算目标
- **注释文档**显式说明规则和约束

### 3.3 意图示例

```python
class CustomerService:
    """处理客户服务请求的服务类"""
    
    def handle_inquiry(self, message: str) -> str:
        """
        处理客户咨询
        
        要求：
        - 使用礼貌、专业的语气
        - 如果问题涉及退款，引导客户联系财务部门
        """
        # 语义调用：generate_response 未定义
        response = self.generate_response(message)
        return response
```

在这个例子中，`generate_response` 是一个语义调用，其意图通过以下元素表达：

- 类名 `CustomerService` 暗示客户服务领域
- 方法名 `generate_response` 暗示生成响应的任务
- 参数类型 `str` 和返回类型 `str` 表明文本输入输出
- 文档字符串明确了业务规则

## 4. 执行模型与语义执行

### 4.1 双执行流

语义 Python 程序的执行由两个执行流组成：

1. **Python 执行流**：标准 Python 解释器执行确定性代码
2. **语义执行流**：语义执行引擎根据意图进行推理并生成响应

程序在这两个执行流之间切换：

```
[Python 执行流] → [语义调用] → [语义执行流] → [返回值] → [Python 执行流]
```

### 4.2 执行流的切换

**进入语义执行流**：

- 触发条件：遇到无法解析的调用
- 切换过程：
  1. Python 解释器捕获调用请求
  2. 收集调用上下文信息（见 3.1 节）
  3. 将控制权转移给语义执行引擎
  
**返回 Python 执行流**：

- 触发条件：语义执行完成并产生返回值
- 切换过程：
  1. 语义执行引擎生成返回值
  2. 返回值被传递回调用点
  3. Python 解释器继续执行后续代码

### 4.3 执行流的隔离性

两个执行流在以下方面是隔离的：

- **状态独立**：语义执行不直接访问 Python 运行时状态
- **数据交换**：只通过调用参数和返回值交换数据
- **错误传播**：两个流各自的错误处理机制独立

### 4.4 语义执行的输入

语义执行引擎接收两类输入：

1. **静态输入**：调用上下文（蕴含意图）
2. **动态输入**：实际调用时的参数值

### 4.5 语义执行的过程

1. **意图理解**：
   - 解析调用上下文
   - 提取类型、标识符、文档等信息
   - 推断程序员期望完成的任务

2. **推理计算**：
   - 结合意图和实际参数值
   - 通过语义推理生成输出
   - 生成满足意图的结果

3. **返回值生成**：
   - 根据推断的返回类型构造返回值
   - 确保返回值符合类型约束
   - 将返回值传回 Python 执行流

### 4.6 语义执行的确定性

- **意图确定**：调用上下文在源代码编写完成后固定，因此意图是确定的
- **实现不确定**：如何满足意图由运行时推理决定，实现方式可能因模型、数据而异
- **结果一致性**：对于相同的意图和参数，期望产生语义等价的结果

## 5. 类型系统

### 5.1 类型在语义调用中的作用

类型信息是意图表达的重要组成部分：

- **参数类型**：描述任务所需的输入信息结构
- **返回类型**：描述任务应产生的输出结构
- **字段名称**：类型内部的字段名传达数据的业务含义

### 5.2 类型推断

语义 Python 支持从上下文推断类型：

- 从类型注解直接获取
- 从赋值目标类型推断
- 从函数返回类型推断
- 从数据流分析推断

### 5.3 类型示例

```python
from dataclasses import dataclass

@dataclass
class SentimentResult:
    """情感分析结果"""
    polarity: str  # "positive", "negative", "neutral"
    confidence: float  # 0.0 到 1.0
    key_phrases: list[str]

def analyze_text(text: str) -> SentimentResult:
    # 语义调用：extract_sentiment 未定义
    # 意图通过返回类型 SentimentResult 的结构明确传达
    return extract_sentiment(text)
```

这里，`SentimentResult` 类型的结构明确传达了情感分析任务的输出要求。

## 6. 语法兼容性

### 6.1 向后兼容

语义 Python 代码在语法层面是合法的 Python 代码：

- 可以被标准 Python 解析器解析
- 可以通过语法检查和静态分析工具
- 在标准 Python 环境中会产生运行时错误，但不会产生语法错误

### 6.2 渐进式采用

程序员可以在 Python 项目中渐进式地引入语义调用：

- 大部分代码保持传统实现
- 仅在需要灵活性的部分使用语义调用
- 语义调用和传统调用可以自由混合

## 7. 语言哲学

### 7.1 抽象层次

语义 Python 引入了新的抽象层次：

- **传统编程**：程序员编写"如何做"（How）
- **语义编程**：程序员声明"做什么"（What）

语义调用将"如何做"的决策从编程时推迟到运行时。

### 7.2 意图与实现的分离

语义 Python 将程序的两个方面解耦：

- **意图**：程序员期望完成的任务（通过代码结构表达）
- **实现**：完成任务的具体步骤（由运行时推理生成）

这种分离带来了灵活性，但也要求程序员更加关注意图的清晰表达。

### 7.3 确定性与推理的平衡

语义 Python 程序在确定性代码和推理代码之间取得平衡：

- 对于逻辑明确、性能关键的部分，使用传统 Python 代码
- 对于需要灵活理解、难以明确编码的部分，使用语义调用

程序员需要判断何时使用哪种方式，这是语义 Python 编程的核心技能。