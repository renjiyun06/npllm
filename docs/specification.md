# Semantic Python Language Specification

## 1. Overview

### 1.1 Definition of Semantic Python

Semantic Python is an extension of the Python language that introduces **semantic calls** as a new form of invocation while maintaining complete syntax compatibility. Semantic calls exist at the same abstraction level as function calls and method calls, forming the third type of Python's invocation mechanism.

### 1.2 Relationship with Standard Python

In standard Python, when the interpreter encounters a function or method call that cannot be resolved, it raises a `NameError` or `AttributeError` exception. Semantic Python changes this behavior:

- **Standard Python**: Unresolved call → Runtime error
- **Semantic Python**: Unresolved call → Semantic call → Semantic execution flow

This change allows programmers to write code that is syntactically valid but "incomplete" in the traditional sense, deferring the implementation of certain computations to runtime through semantic inference.

## 2. Semantic Calls

### 2.1 Definition of Semantic Calls

A **semantic call** occurs during program execution when a call expression cannot be resolved to an executable function object. Such a call is recognized as a semantic call and enters the semantic execution flow.

Formally, the following situations constitute semantic calls:

1. **Undefined function call**: The function name cannot be resolved in the current scope or any outer scope
   ```python
   result = analyze_sentiment(text)  # analyze_sentiment is undefined
   ```

2. **Undefined method call**: The method called on an object does not exist in the object's class or inheritance chain
   ```python
   customer.calculate_lifetime_value()  # Customer class has no such method
   ```

### 2.2 Recognition Timing of Semantic Calls

Semantic calls are recognized at **runtime**, not at compile time or parse time. This means:

- Code is valid Python code during the syntax analysis phase
- Only when execution reaches the call statement is it determined whether the call is semantic
- This preserves Python's dynamic nature and syntax compatibility

### 2.3 Comparison Between Semantic Calls and Traditional Calls

| Feature | Function/Method Call | Semantic Call |
|---------|---------------------|---------------|
| Resolution timing | Resolved to function object at runtime | Cannot be resolved at runtime |
| Implementation location | Explicitly defined in code | Generated by runtime inference |
| Behavioral determinism | Fully deterministic | Determined by intent and context |
| Error handling | Raises exception if undefined | Enters semantic flow if undefined |

## 3. Intent Expression Mechanism

### 3.1 Call Context

When a program enters the semantic execution flow, the semantic execution engine needs to understand the programmer's intent. Intent information is embedded in the **call context**.

The call context includes:

1. **Code container** (by priority):
   - If the call is inside a class: The complete definition of that class
   - Otherwise, if the call is inside a function: The complete definition of that function
   - Otherwise: The relevant code of the module

2. **Type information**:
   - Types of call parameters (from type annotations or inference)
   - Type of return value (from type annotations or inference)
   - Complete definitions of related types

3. **Identifiers**:
   - Name of the called function/method
   - Parameter names
   - Related variable names

4. **Documentation and comments**:
   - Docstrings of related code
   - Comments in related code

### 3.2 Encoding Intent

Intent is not the code itself, but the task the programmer expects the semantic call to accomplish. Intent is encoded through multiple dimensions in the call context:

- **Type signatures** convey the data structure of inputs and outputs
- **Identifiers** carry natural language semantics, suggesting the nature of the task
- **Code logic** reveals the business scenario and computational goal
- **Comments and documentation** explicitly state rules and constraints

### 3.3 Intent Example

```python
class CustomerService:
    """Service class for handling customer service requests"""
    
    def handle_inquiry(self, message: str) -> str:
        """
        Handle customer inquiry
        
        Requirements:
        - Use polite and professional tone
        - If the question involves refunds, guide customer to contact finance
        """
        # Semantic call: generate_response is undefined
        response = self.generate_response(message)
        return response
```

In this example, `generate_response` is a semantic call, and its intent is expressed through:

- Class name `CustomerService` suggests the customer service domain
- Method name `generate_response` suggests the task of generating a response
- Parameter type `str` and return type `str` indicate text input/output
- Docstring specifies business rules

## 4. Execution Model and Semantic Execution

### 4.1 Dual Execution Flows

Semantic Python program execution consists of two execution flows:

1. **Python execution flow**: The standard Python interpreter executes deterministic code
2. **Semantic execution flow**: The semantic execution engine performs inference based on intent and generates responses

The program switches between these two execution flows:

```
[Python execution flow] → [Semantic call] → [Semantic execution flow] → [Return value] → [Python execution flow]
```

### 4.2 Execution Flow Switching

**Entering semantic execution flow**:
- Trigger condition: Encountering an unresolved call
- Switching process:
  1. Python interpreter captures the call request
  2. Collects call context information (see Section 3.1)
  3. Transfers control to the semantic execution engine
  
**Returning to Python execution flow**:
- Trigger condition: Semantic execution completes and produces a return value
- Switching process:
  1. Semantic execution engine generates return value
  2. Return value is passed back to the call site
  3. Python interpreter continues executing subsequent code

### 4.3 Isolation of Execution Flows

The two execution flows are isolated in the following aspects:

- **State independence**: Semantic execution does not directly access Python runtime state
- **Data exchange**: Only exchanges data through call parameters and return values
- **Error propagation**: Each flow has its own independent error handling mechanism

### 4.4 Inputs to Semantic Execution

The semantic execution engine receives two types of inputs:

1. **Static input**: Call context (encoding intent)
2. **Dynamic input**: Actual parameter values at call time

### 4.5 Semantic Execution Process

1. **Intent understanding**:
   - Parse call context
   - Extract types, identifiers, documentation, and other information
   - Infer the task the programmer expects to accomplish

2. **Inference and computation**:
   - Combine intent with actual parameter values
   - Perform semantic inference to generate output
   - Generate results that satisfy the intent

3. **Return value generation**:
   - Construct return value based on inferred return type
   - Ensure return value conforms to type constraints
   - Pass return value back to Python execution flow

### 4.6 Determinism in Semantic Execution

- **Intent determinism**: Call context is fixed once source code is written, so intent is deterministic
- **Implementation non-determinism**: How to satisfy the intent is decided by runtime inference, and implementation may vary with different models and data
- **Result consistency**: For the same intent and parameters, results are expected to be semantically equivalent

## 5. Type System

### 5.1 Role of Types in Semantic Calls

Type information is an important component of intent expression:

- **Parameter types**: Describe the structure of input information required for the task
- **Return type**: Describes the structure of output to be produced by the task
- **Field names**: Field names within types convey the business meaning of data

### 5.2 Type Inference

Semantic Python supports inferring types from context:

- Obtained directly from type annotations
- Inferred from assignment target type
- Inferred from function return type
- Inferred from data flow analysis

### 5.3 Type Example

```python
from dataclasses import dataclass

@dataclass
class SentimentResult:
    """Sentiment analysis result"""
    polarity: str  # "positive", "negative", "neutral"
    confidence: float  # 0.0 to 1.0
    key_phrases: list[str]

def analyze_text(text: str) -> SentimentResult:
    # Semantic call: extract_sentiment is undefined
    # Intent is clearly conveyed through the structure of return type SentimentResult
    return extract_sentiment(text)
```

Here, the structure of the `SentimentResult` type clearly conveys the output requirements of the sentiment analysis task.

## 6. Syntax Compatibility

### 6.1 Backward Compatibility

Semantic Python code is valid Python code at the syntax level:

- Can be parsed by standard Python parsers
- Can pass syntax checking and static analysis tools
- Will produce runtime errors in standard Python environments, but not syntax errors

### 6.2 Gradual Adoption

Programmers can gradually introduce semantic calls into Python projects:

- Most code maintains traditional implementation
- Only use semantic calls in parts requiring flexibility
- Semantic calls and traditional calls can be freely mixed

## 7. Language Philosophy

### 7.1 Abstraction Level

Semantic Python introduces a new level of abstraction:

- **Traditional programming**: Programmers write "how to do it" (How)
- **Semantic programming**: Programmers declare "what to do" (What)

Semantic calls defer the decision of "how to do it" from programming time to runtime.

### 7.2 Separation of Intent and Implementation

Semantic Python decouples two aspects of programs:

- **Intent**: The task the programmer expects to accomplish (expressed through code structure)
- **Implementation**: The specific steps to accomplish the task (generated by runtime inference)

This separation brings flexibility, but also requires programmers to focus more on clear expression of intent.

### 7.3 Balance Between Determinism and Inference

Semantic Python programs achieve a balance between deterministic code and inference code:

- For parts with clear logic and critical performance, use traditional Python code
- For parts requiring flexible understanding and difficult to explicitly encode, use semantic calls

Programmers need to judge when to use which approach, which is a core skill in Semantic Python programming.