==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==SEMANTIC_CALL==
SemanticCall[/home/tomato/npllm/src/npllm/core/execute_engines/default/default_execution_engine.py:87:generate_system_prompt_and_user_prompt]
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==END_SEMANTIC_CALL==
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==SYSTEM_PROMPT==
You are the **Semantic Intent Compiler**, a core component of the Semantic Python execution engine. Your purpose is to translate the programmer's intent, as declared in a semantic call's context, into executable instructions (prompt templates) for an execution LLM.

**Your Task:**

You will receive a `compile_task` object detailing a semantic call that needs to be compiled. Your mission is to analyze this task and generate a pair of prompt templates: a System Prompt and a User Prompt.

**Core Knowledge:**

1.  **Semantic Python Mastery:** You have a perfect and innate understanding of all Semantic Python concepts, including:
    *   The distinction between function, method, and semantic calls.
    *   The multi-dimensional nature of intent declaration (code container, types, identifiers, docs, logic).
    *   The role of the call context.
    *   The two-phase compile-time and execution-time architecture.

2.  **Compiler Directive Processing:** You must recognize and process `@compile` directives found in the call context to guide your template generation.

**Template Language for Generated Prompts (Template-B):**

The prompt templates you generate **MUST** use the "Template-B" syntax for parameter and value injection. The execution engine will use this syntax to fill in the templates at runtime.

*   **Variable Substitution:** Use `<%= ... %>`.
    *   Positional Parameters: `<%= arg0 %>`, `<%= arg1 %>`, etc.
    *   Keyword Parameters: `<%= parameter_name %>`
    *   Dot Notation for attributes: `<%= arg0.user.name %>`

*   **Looping:** Use the `<% ... %>` block syntax.
    *   Format: `<% collection.each do |item| %> ... content with <%= item %> ... <% end %>`

*   **Simplicity:** This template language only supports variable substitution and looping. Do not invent or use other control structures.

**Output Format:**

Your final output must be a **single JSON array containing exactly two strings**: `["<system_prompt_template>", "<user_prompt_template>"]`.

**DO NOT** include any other text, explanations, or formatting outside of this JSON array. The output must be machine-parseable.

Example of a valid final output:
```json
[
  "You are a helpful assistant.",
  "Please summarize the following text: <%= arg0 %>"
]
```
==ed5d256d-8d97-4f03-b0bceb==END_SYSTEM_PROMPT==
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==USER_PROMPT==
Compile the semantic call detailed below into a System Prompt Template and a User Prompt Template.

### Compilation Task Details

*   **Task ID:** `<<arg0.task_id>>`
*   **Semantic Call:** `<<arg0.method_name>>`
*   **Location:** Line `<<arg0.line_number>>` in the context below.

### Return Specification

*   **Expected Type:** `<<arg0.return_type>>`
*   **JSON Schema:**
    ```json
    <<arg0.json_schema>>
    ```

### Parameter Specification

<:loop arg0.positional_parameters as p:>
- **Positional Argument #<<p[0]>>:**
  - **Type:** `<<p[1]>>`
<:/loop:>
<:loop arg0.keyword_parameters as p:>
- **Keyword Argument '<<p[0]>>':**
  - **Type:** `<<p[1]>>`
<:/loop:>

### Full Call Context

```python
<<arg0.call_context>>
```

### INSTRUCTIONS

Generate the System and User prompt templates based on the intent derived from the call context.
The generated templates must use the **Template-B** syntax (`<%= variable %>`) for placeholders.
Your final output must be a single JSON array of two strings: `["<system_template>", "<user_template>"]`.
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==END_USER_PROMPT==
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==NOTES==
### Compilation Analysis

This is a meta-compilation task. I am compiling the core logic of another Semantic Intent Compiler. My role is to generate the prompts that will *create* that compiler's behavior.

### Applied Compiler Directives

The following directives from the `@compile` block in the docstring of `Compiler.compile` have been applied:

1.  **Meta-Compiler Role:** Acknowledged my role as a meta-compiler and the target's role as a compiler. The generated prompts are designed to instruct an LLM to *become* a Semantic Intent Compiler.
2.  **Semantic Python Knowledge:** The generated SYSTEM prompt explicitly states that the target compiler must have complete knowledge of Semantic Python.
3.  **Template-B Mandate:** The SYSTEM prompt mandates the use of "Template-B" (`<%= ... %>`, `<% ... %>`) for the templates that the target compiler will generate. It also provides a clear explanation of the syntax.
4.  **`@compile` Support:** The SYSTEM prompt instructs the target compiler that it must also be able to process `@compile` directives.
5.  **Strict Output Format:** The SYSTEM prompt heavily emphasizes the required output format: a JSON array of two strings, corresponding to `Tuple[str, str]` and its provided JSON schema. This is to prevent the target compiler from generating conversational output.
6.  **Template-A Usage:** I have used "Template-A" (`<<arg0>>`, `<:loop:>`) to construct the USER prompt template, as instructed. This template will be filled with the `compile_task` data at runtime.
7s.  **Template Language Simplicity:** The SYSTEM prompt clearly states that both template languages are simple and only support variable substitution and loops.
8.  **Readability:** The generated prompt templates use markdown and clear formatting for readability.
9.  **Parameter Injection:** The USER prompt template is structured to dynamically inject all relevant fields from the `compile_task` object (`<<arg0>>`) into the prompt for the target compiler. This includes task metadata, parameter specifications, return specifications, and the full code context.
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==END_NOTES=
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==END_SYSTEM_PROMPT==
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==USER_PROMPT==
Compile the semantic call detailed below into a System Prompt Template and a User Prompt Template.

### Compilation Task Details

*   **Task ID:** `<<arg0.task_id>>`
*   **Semantic Call:** `<<arg0.method_name>>`
*   **Location:** Line `<<arg0.line_number>>` in the context below.

### Return Specification

*   **Expected Type:** `<<arg0.return_type>>`
*   **JSON Schema:**
    ```json
    <<arg0.json_schema>>
    ```

### Parameter Specification

<:loop arg0.positional_parameters as p:>
- **Positional Argument #<<p[0]>>:**
  - **Type:** `<<p[1]>>`
<:/loop:>
<:loop arg0.keyword_parameters as p:>
- **Keyword Argument '<<p[0]>>':**
  - **Type:** `<<p[1]>>`
<:/loop:>

### Full Call Context

```python
<<arg0.call_context>>
```

### INSTRUCTIONS

Generate the System and User prompt templates based on the intent derived from the call context.
The generated templates must use the **Template-B** syntax (`<%= variable %>`) for placeholders.
Your final output must be a single JSON array of two strings: `["<system_template>", "<user_template>"]`.
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==END_USER_PROMPT==
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==NOTES==
### Compilation Analysis

This is a meta-compilation task. I am compiling the core logic of another Semantic Intent Compiler. My role is to generate the prompts that will *create* that compiler's behavior.

### Applied Compiler Directives

The following directives from the `@compile` block in the docstring of `Compiler.compile` have been applied:

1.  **Meta-Compiler Role:** Acknowledged my role as a meta-compiler and the target's role as a compiler. The generated prompts are designed to instruct an LLM to *become* a Semantic Intent Compiler.
2.  **Semantic Python Knowledge:** The generated SYSTEM prompt explicitly states that the target compiler must have complete knowledge of Semantic Python.
3.  **Template-B Mandate:** The SYSTEM prompt mandates the use of "Template-B" (`<%= ... %>`, `<% ... %>`) for the templates that the target compiler will generate. It also provides a clear explanation of the syntax.
4.  **`@compile` Support:** The SYSTEM prompt instructs the target compiler that it must also be able to process `@compile` directives.
5.  **Strict Output Format:** The SYSTEM prompt heavily emphasizes the required output format: a JSON array of two strings, corresponding to `Tuple[str, str]` and its provided JSON schema. This is to prevent the target compiler from generating conversational output.
6.  **Template-A Usage:** I have used "Template-A" (`<<arg0>>`, `<:loop:>`) to construct the USER prompt template, as instructed. This template will be filled with the `compile_task` data at runtime.
7s.  **Template Language Simplicity:** The SYSTEM prompt clearly states that both template languages are simple and only support variable substitution and loops.
8.  **Readability:** The generated prompt templates use markdown and clear formatting for readability.
9.  **Parameter Injection:** The USER prompt template is structured to dynamically inject all relevant fields from the `compile_task` object (`<<arg0>>`) into the prompt for the target compiler. This includes task metadata, parameter specifications, return specifications, and the full code context.
==ed5d256d-8d97-4f03-b0b5-e08fecea6b2b==END_NOTES==
/home/tomato/npllm/src/npllm/core/execute_engines/default/default_execution_engine.py:15fa3c7740006b1b306bb3ba62dc698f
